// Lesson content for Lessons 7-12 of "AIサービス時代のセキュリティ実践" course
// These content strings should be assigned to the `content` field of each
// corresponding CourseLesson in the curriculum array of the course with
// slug "ai-security-for-startups-2026" in courses.ts.
//
// Example merge (in courses.ts):
//   import { lesson7Content, lesson8Content, ... } from "./lessons-7-12";
//   // Then in the curriculum array, for lesson number 7:
//   { number: 7, title: "...", duration: "30分", isFree: false, content: lesson7Content },

export const lesson7Content = `## 第7回：SaaS選定時のセキュリティチェックリスト

こんにちは、濱田優貴です。

今回は、スタートアップが避けて通れない「SaaS選定」のセキュリティについて話します。メルカリ時代、僕たちは何十ものSaaSを導入していました。Slack、Salesforce、Datadog、PagerDuty...。そして正直に言うと、初期のころはセキュリティ評価なんてほとんどやっていなかった。「便利だから入れよう」で済ませていた時期があります。

それが痛い目を見る原因になりました。あるSaaSベンダーがセキュリティインシデントを起こして、僕たちの顧客データが影響範囲に入っている可能性が浮上したときは、本当に肝が冷えました。

### なぜSaaSのセキュリティ評価が必要なのか

皆さんの会社でも、気づけば10個、20個とSaaSを使っていませんか？ それぞれのSaaSに会社のデータを預けているわけです。つまり、**自社のセキュリティは、一番弱いSaaSベンダーのセキュリティに引きずられる**。これがサプライチェーンリスクの本質です。

### セキュリティ認証を理解する

SaaS選定で最初に確認すべきは、そのベンダーが持っているセキュリティ認証です。主要なものを整理しましょう。

**SOC 2 Type II**
米国公認会計士協会（AICPA）が定めた基準で、セキュリティ、可用性、処理の完全性、機密保持、プライバシーの5つの観点で第三者監査を受けたことを示します。Type IIは一定期間（通常6~12ヶ月）にわたる運用の有効性を証明するもので、Type Iの「ある時点でのスナップショット」より信頼性が高い。**グローバルSaaSを評価するならSOC 2 Type IIは最低ライン**です。

**ISO 27001**
情報セキュリティマネジメントシステム（ISMS）の国際規格。日本企業にはなじみ深い認証で、国内SaaSベンダーの多くが取得しています。ただし、ISO 27001はマネジメントの仕組みを認証するものであって、技術的な堅牢性を直接保証するわけではない点は理解しておきましょう。

**ISMAP（政府情報システムのためのセキュリティ評価制度）**
日本政府が導入したクラウドサービスの安全性評価制度です。官公庁や地方自治体向けにサービスを提供する場合は必須。民間企業でも、ISMAPに登録されているSaaSは一定の信頼性があると判断できます。

\`\`\`
【認証の信頼度マトリクス】
┌─────────────────┬──────────┬──────────────┬─────────────┐
│ 認証              │ 技術的保証 │ 運用プロセス保証 │ 日本での認知度 │
├─────────────────┼──────────┼──────────────┼─────────────┤
│ SOC 2 Type II   │ ★★★      │ ★★★★         │ ★★★         │
│ ISO 27001       │ ★★       │ ★★★★         │ ★★★★★       │
│ ISMAP           │ ★★★      │ ★★★★         │ ★★★         │
│ SOC 2 Type I    │ ★★       │ ★★           │ ★★          │
│ 自己申告のみ      │ ★        │ ★            │ -           │
└─────────────────┴──────────┴──────────────┴─────────────┘
\`\`\`

### データ処理契約（DPA）の確認

認証の次に重要なのが、**Data Processing Agreement（データ処理契約）** です。GDPRの文脈でよく語られますが、日本の個人情報保護法でも委託先との契約は必須です。

DPAで確認すべき項目：

1. **データの保存場所** — どのリージョンに保存されるか。日本国内か、米国か、EUか
2. **データの暗号化** — 保存時（at rest）と転送時（in transit）の両方で暗号化されているか
3. **データの削除ポリシー** — 解約後にデータが完全に削除されるまでの期間と方法
4. **サブプロセッサー** — そのSaaSがさらに別のサービスにデータを委託していないか
5. **インシデント通知義務** — セキュリティインシデント発生時の通知期限（72時間以内が望ましい）

### ベンダーリスクアセスメント実践

Enablerでは、新しいSaaSを導入するときに以下のスコアカードを使っています。

\`\`\`
【SaaSセキュリティ評価スコアカード】

■ 認証・コンプライアンス（30点）
  - SOC 2 Type II取得: 10点
  - ISO 27001取得: 5点
  - ISMAP登録: 5点
  - プライバシーマーク: 3点
  - ペネトレーションテスト実施: 7点

■ データ保護（25点）
  - 暗号化（at rest + in transit）: 8点
  - データ保存リージョン選択可: 5点
  - バックアップ・復旧体制: 5点
  - データ削除ポリシー明確: 4点
  - DPA締結可能: 3点

■ アクセス制御（20点）
  - SSO（SAML/OIDC）対応: 8点
  - MFA対応: 5点
  - RBAC（役割ベースアクセス制御）: 4点
  - 監査ログ: 3点

■ 運用体制（15点）
  - SLA 99.9%以上: 5点
  - インシデント対応体制公開: 5点
  - ステータスページ公開: 3点
  - セキュリティ連絡窓口: 2点

■ 事業継続性（10点）
  - 財務健全性: 4点
  - データポータビリティ: 3点
  - ベンダーロックイン回避策: 3点

合計: ___/100点
→ 80点以上: 導入推奨
→ 60-79点: 条件付き導入（リスク受容の判断が必要）
→ 60点未満: 導入非推奨
\`\`\`

### よくある落とし穴

メルカリやEnablerでの経験から、SaaS選定でよくある失敗パターンを共有します。

1. **無料プランで試して、そのまま本番運用** — 無料プランにはSSO対応も監査ログもないことが多い。セキュリティ機能はエンタープライズプランにしかないケースがほとんどです
2. **個人のクレジットカードで契約** — シャドーITの温床。退職時にアカウントが引き継がれず、データが消える
3. **API連携のトークン管理が杜撰** — SaaS間をつなぐAPIトークンが平文でSlackに貼られている。これ、本当によくあります

### ポイント

- SaaSの選定は「便利さ」だけでなく「セキュリティ認証」「DPA」「アクセス制御」を総合的に評価する
- SOC 2 Type II、ISO 27001、ISMAPの違いを理解し、用途に応じて要求水準を設定する
- スコアカードを使った定量的な評価で、属人的な判断を排除する
- 無料プランと有料プランでセキュリティ機能が大きく異なる点に注意する
- データ処理契約（DPA）は必ず締結し、サブプロセッサーまで確認する

### 実践ワーク

あなたの会社（またはプロジェクト）で現在使っているSaaSを3つ選び、上記のスコアカードで評価してください。各SaaSについて以下を調査・記録しましょう：

1. どのセキュリティ認証を取得しているか（各社のセキュリティページやTrust Centerで確認）
2. DPAは締結されているか／締結可能か
3. SSOに対応しているか。対応している場合、どのプランからか
4. 最終的なスコアは何点か。60点未満のSaaSがあった場合、代替手段を1つ提案してください

この演習を通じて、SaaS選定を「感覚」から「プロセス」に変えることが目標です。`;

export const lesson8Content = `## 第8回：OAuth/SSO/パスキー — 認証の最前線

こんにちは、濱田優貴です。

今回は認証技術の最前線について話します。メルカリでCPOをやっていたとき、認証基盤のリニューアルは最も緊張感のあるプロジェクトの一つでした。何千万人ものユーザーが毎日ログインするシステムで、認証に問題が起きたら即座にビジネスインパクトが出ます。

そしてEnablerを立ち上げてからは、「2026年の新規サービスでどの認証方式を採用すべきか」を真剣に考えました。結論を先に言うと、**パスキーを第一選択にすべき時代が来ています**。でもその前に、なぜそうなるのかを理解するために、OAuth 2.0からSSO、そしてパスキーまでを順番に見ていきましょう。

### OAuth 2.0 / OIDC をシンプルに理解する

OAuth 2.0は「認可」のプロトコルで、OpenID Connect（OIDC）はその上に「認証」を乗せた仕組みです。これ、エンジニアでも混同している人が多い。

\`\`\`
【OAuth 2.0 Authorization Code Flow（簡略版）】

ユーザー → あなたのアプリ → 認可サーバー（Google等）
  1. ユーザーが「Googleでログイン」をクリック
  2. アプリが認可サーバーにリダイレクト
  3. ユーザーがGoogleで認証＆同意
  4. 認可サーバーが「認可コード」をアプリに返す
  5. アプリがバックエンドで認可コードを「アクセストークン」に交換
  6. アプリがアクセストークンでユーザー情報を取得

重要: ステップ5は必ずバックエンド（サーバーサイド）で行う！
      フロントエンドでやると、クライアントシークレットが漏洩します。
\`\`\`

OAuth 2.0でよくあるミスは、**Implicit Flow（暗黙的フロー）を使ってしまうこと**です。これはフロントエンドだけで完結する簡易的なフローですが、トークンがURLフラグメントに含まれるため、ブラウザ履歴やリファラーから漏洩するリスクがあります。2026年の新規開発では、**必ずAuthorization Code Flow + PKCE**を使ってください。

\`\`\`typescript
// Next.jsでのOAuth実装例（next-auth使用）
// app/api/auth/[...nextauth]/route.ts
import NextAuth from "next-auth";
import GoogleProvider from "next-auth/providers/google";

export const authOptions = {
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
      authorization: {
        params: {
          // PKCEは next-auth が自動で処理
          prompt: "consent",
          access_type: "offline",
          response_type: "code",
        },
      },
    }),
  ],
  callbacks: {
    async signIn({ account, profile }) {
      // メールドメインで制限（社内ツールの場合）
      if (account?.provider === "google") {
        return profile?.email?.endsWith("@yourcompany.com") ?? false;
      }
      return true;
    },
  },
};
\`\`\`

### SSO実装パターン：SAMLとOIDC

企業向けSaaSを作るなら、SSO（シングルサインオン）対応は避けて通れません。SSOには主にSAML 2.0とOIDCの2つの実装パターンがあります。

**SAML 2.0** — XMLベースの古いプロトコル。エンタープライズ環境で広く使われていて、Active Directory（Azure AD）との連携でよく見ます。実装が複雑で、XMLの署名検証を間違えるとセキュリティホールになりやすい。

**OIDC** — JSON/RESTベースのモダンなプロトコル。OAuth 2.0の拡張で、実装がシンプル。新規開発ならこちらを推奨。

僕の経験則として、**エンタープライズ顧客を持つならSAMLとOIDCの両方に対応すべき**です。顧客のIT部門が「うちはSAMLしか許可していない」と言ってくるケースは今でも多い。ただし自社でSAMLパーサーを実装するのは危険なので、WorkOS、Auth0、Clerkのような認証SaaSを使うのが現実的です。

### パスキー（WebAuthn/FIDO2）— パスワードが死ぬ時代

ここからが今回の本題です。パスキーは、**パスワードを完全に置き換える認証技術**です。

仕組みを簡単に説明すると：

\`\`\`
【パスキーの仕組み】

登録時:
  1. サーバーが「チャレンジ」を生成
  2. デバイスが公開鍵ペアを生成
  3. 秘密鍵はデバイス内（Secure Enclave等）に保存
  4. 公開鍵をサーバーに送信・登録

ログイン時:
  1. サーバーが新しい「チャレンジ」を生成
  2. ユーザーが生体認証（Face ID等）で秘密鍵の使用を承認
  3. 秘密鍵でチャレンジに署名
  4. サーバーが公開鍵で署名を検証

→ パスワードがネットワーク上を流れない！
→ フィッシングサイトでは秘密鍵が使えない（オリジン検証）！
→ サーバー側に秘密情報が保存されない！
\`\`\`

パスキーがパスワードより圧倒的に優れている理由は3つです：

1. **フィッシング耐性** — パスキーはオリジン（ドメイン）に紐づくので、偽サイトでは一切機能しない
2. **サーバー漏洩耐性** — サーバーに保存されるのは公開鍵だけ。漏洩しても悪用不可
3. **ユーザー体験** — パスワードを覚える必要なし。Face IDやTouch IDで一瞬

Apple、Google、Microsoftが2022年にパスキーのクロスプラットフォーム対応を発表して以来、2026年には主要ブラウザとOSのすべてでサポートされています。

### パスワードが死ぬ理由

メルカリ時代、パスワードリスト攻撃（他サービスで漏洩したID/パスワードの組み合わせを試す攻撃）は日常茶飯事でした。ユーザーの多くが同じパスワードを使い回しているので、どこかで漏洩すると連鎖的に被害が広がる。

SMSベースの2FAも万全ではありません。SIMスワップ攻撃やSMSの傍受は現実に起きています。TOTP（Google Authenticatorなど）はましですが、フィッシングには無力です。

パスキーは、これらの問題をすべて解決します。2026年の新規サービスなら、**パスキーをデフォルトの認証方式にして、パスワードはフォールバックとして残す**のが最善の設計です。

### 認証フローの設計指針

新しいSaaSの認証フローを設計するときの僕の推奨パターンはこうです：

\`\`\`
【2026年推奨の認証フロー設計】

一般ユーザー向けSaaS:
  第一選択: パスキー（WebAuthn）
  第二選択: ソーシャルログイン（Google/Apple OIDC）
  フォールバック: メール + パスワード + TOTP

企業向けSaaS:
  第一選択: SSO（SAML/OIDC）← 顧客のIdP
  第二選択: パスキー
  フォールバック: メール + パスワード + TOTP
  必須: 管理者によるMFA強制設定
\`\`\`

### ポイント

- OAuth 2.0は「認可」、OIDCは「認証」。必ずAuthorization Code Flow + PKCEを使う
- Implicit Flowは使わない。2026年の新規開発では非推奨
- エンタープライズ顧客にはSAML/OIDCの両方でSSO対応する。自前実装は避け、認証SaaSを活用
- パスキーはフィッシング耐性・サーバー漏洩耐性・UXのすべてでパスワードに勝る
- 新規サービスはパスキーをデフォルトにし、パスワードはフォールバックに留める

### 実践ワーク

あなたが新しいSaaSプロダクトを立ち上げると仮定して、認証フローを設計してください：

1. ターゲットユーザー（一般ユーザー向け or 企業向け）を決める
2. 登録フロー（サインアップ）を図で描く — どの認証方式を第一選択にするか
3. ログインフローを図で描く — パスキー、ソーシャルログイン、パスワード、SSOの優先順位
4. パスワードリセットフローを設計する — パスキーがある場合、パスワードリセットは必要か？
5. 管理者向けのセキュリティ設定画面に必要な項目を5つ以上列挙する（例：MFA強制、セッションタイムアウト等）

認証は「後から変える」のが最もコストが高い部分です。最初の設計で8割が決まると思って取り組んでください。`;

export const lesson9Content = `## 第9回：個人情報保護法 x AI — 2026年改正対応

こんにちは、濱田優貴です。

今回は法律の話です。正直に言うと、僕はエンジニア出身なので法律は苦手でした。でもメルカリでCPOをやっていたとき、個人情報保護法への対応がプロダクト開発のボトルネックになる場面を何度も経験しました。「法律を知らないから開発が止まる」——これはスタートアップにとって致命的です。

そしてAIの時代になって、この問題はさらに複雑になっています。2026年の個人情報保護法改正では、AI利用に関する規定が大幅に強化されました。知らないでは済まされません。

### 個人情報保護法の基本をおさらい

まず基本から。日本の個人情報保護法で押さえるべき概念は3つです。

**個人情報** — 生存する特定の個人を識別できる情報。氏名、メールアドレス、顔写真はもちろん、他の情報と容易に照合して個人を特定できる情報も含みます。

**個人データ** — 個人情報データベース等に含まれる個人情報。つまり、体系的に整理されてデータベースに格納された個人情報のことです。

**要配慮個人情報** — 人種、信条、病歴、犯罪歴など、不当な差別や偏見につながりうる情報。AI利用において特に注意が必要なカテゴリです。

### 2026年改正のAI関連ポイント

2026年の改正で、AIサービスに直接影響する重要な変更点を整理します。

**1. AIによるプロファイリングへの規制強化**

AIを使って個人の行動、嗜好、信用力などを自動的に分析・評価する「プロファイリング」について、本人への通知義務が強化されました。具体的には：

- AIがユーザーの個人データを分析して判断を行う場合、その事実を本人に通知する義務
- 自動的な判断が本人に重大な影響を及ぼす場合、人間による審査を求める権利の付与
- プロファイリングに使用するデータ項目とロジックの概要を公表する義務

\`\`\`
【プロファイリング通知の実装例】

// プライバシーポリシーに記載すべき内容
const aiProfilingDisclosure = {
  purpose: "AIによるコンテンツレコメンデーション",
  dataUsed: [
    "閲覧履歴",
    "検索キーワード",
    "購買履歴",
    "デバイス情報"
  ],
  logicOverview: "機械学習モデルにより、過去の行動データから"
    + "興味関心を推定し、関連性の高いコンテンツを表示します",
  optOutMethod: "設定画面から無効化可能",
  humanReview: "重要な判断（与信・採用等）には人間の審査を介在させます"
};
\`\`\`

**2. AI学習データとしての利用に関する規定**

自社が保有する個人データをAIモデルの学習（ファインチューニング含む）に利用する場合のルールが明確化されました。

- 利用目的の特定義務が厳格化：「AIの品質改善のため」だけでは不十分。具体的にどの機能の改善にどのデータを使うかを特定する必要がある
- 学習データからの個人の権利（削除要求への対応）：学習済みモデルからの特定個人のデータ削除は技術的に困難だが、合理的な代替措置を講じる義務
- 第三者AIサービス（ChatGPT、Claude等）への個人データ入力に関する委託先管理義務

**3. 越境データ移転の厳格化**

海外のAIサービスを利用する場合（つまりほぼすべてのケース）、個人データの越境移転に関する規制が強化されています。

### GDPRとの比較

グローバルにサービスを展開する場合、GDPRとの違いも理解しておく必要があります。

\`\`\`
【個人情報保護法 vs GDPR 主要比較】

項目              │ 日本（2026年改正）   │ GDPR
─────────────────┼───────────────────┼──────────────────
同意の要件         │ 黙示の同意も可      │ 明示的同意が必要
自動判断への権利    │ 重大な影響時のみ     │ 包括的な異議権
データ持ち出し権    │ 限定的             │ 広範なポータビリティ権
制裁金            │ 最大1億円          │ 売上の4%（数百億規模）
域外適用          │ あり（日本居住者対象） │ あり（EU居住者対象）
DPO任命義務       │ なし               │ 一定条件で必須
\`\`\`

ポイントは、GDPRの方が全般的に厳しいということです。EUのユーザーがいる場合はGDPR対応が必要になるので、**最初からGDPR準拠で設計しておくと、日本法への対応も自動的にクリアできる**というのが僕の実践的なアドバイスです。

### AIサービスでのプライバシー影響評価（PIA）

Enablerでは、新しいAI機能をリリースする前に必ずプライバシー影響評価（Privacy Impact Assessment）を実施しています。これは法的義務というより、リスクを事前に洗い出すための実務的なプロセスです。

PIAで確認すべき項目：

1. **データの収集** — どんな個人データを、どの手段で収集するか
2. **利用目的** — AIがそのデータをどう処理し、何の目的で使うか
3. **データの共有** — 第三者（AI APIプロバイダー含む）にデータが渡るか
4. **保存期間** — いつまで保存し、どのように削除するか
5. **リスクの特定** — 漏洩・誤用・差別的利用のリスクはどの程度か
6. **軽減策** — 匿名化、仮名化、アクセス制御、暗号化等の対策
7. **本人の権利** — 開示請求、削除請求にどう対応するか

### よくある違反パターン

メルカリ時代やEnablerのコンサルで見てきた、スタートアップがやりがちな違反パターンを挙げます。

- **ChatGPTに顧客データを貼り付けて分析** — これは個人データの第三者提供に該当する可能性がある。API経由でも、OpenAIの利用規約とDPAを確認すべき
- **プライバシーポリシーが古いまま** — AI機能を追加したのにプライバシーポリシーを更新していない。利用目的の通知義務違反
- **同意なくAI学習に使う** — ユーザーがサービス利用時に入力したデータを、断りなく自社AIの学習に転用する

### ポイント

- 2026年改正で、AIプロファイリングへの通知義務と人間審査要求権が新設された
- AI学習へのデータ利用は、具体的な利用目的の特定と通知が必要
- 海外AIサービス利用は越境データ移転に該当する。委託先管理義務を果たすこと
- GDPRの方が厳しいので、グローバル展開するならGDPR準拠で設計すると効率的
- 新しいAI機能のリリース前にはプライバシー影響評価（PIA）を必ず実施する

### 実践ワーク

あなたのサービス（または架空のサービス）にAI機能を追加すると仮定して、プライバシー影響評価（PIA）を実施してください：

1. 追加するAI機能を具体的に定義する（例：「ユーザーのチャット履歴を分析してFAQを自動生成する機能」）
2. その機能で扱う個人データを列挙する
3. 第三者AIサービスを利用する場合、どのサービスにどのデータが渡るかを整理する
4. リスクを3つ以上特定し、それぞれの軽減策を記述する
5. プライバシーポリシーに追記すべき文言のドラフトを作成する

法律は「知らなかった」が通用しない領域です。PIAを習慣にすることで、リリース後に「やばい」と気づく事態を防げます。`;

export const lesson10Content = `## 第10回：AIを使った脅威検知とセキュリティ自動化

こんにちは、濱田優貴です。

ここまでの回では「AIサービスのセキュリティリスク」を中心に話してきましたが、今回は逆です。**AIを味方にして、セキュリティを強化する方法**を学びましょう。

メルカリ時代、セキュリティチームが毎日見ているアラートの量は尋常ではありませんでした。不正ログインの試行、異常なAPI呼び出し、マルウェアの検知...。人間だけでは到底さばききれない。そこでAI・機械学習を活用した脅威検知が不可欠になります。

### AI活用セキュリティツールの全体像

まず、セキュリティ領域でAIがどのように使われているかを俯瞰しましょう。

\`\`\`
【セキュリティにおけるAI活用マップ】

検知（Detection）
├── 異常検知（Anomaly Detection）
│   ├── ネットワークトラフィックの異常
│   ├── ユーザー行動の異常（UEBA）
│   └── API呼び出しパターンの異常
├── マルウェア検知
│   └── パターンマッチング + ML分類
└── フィッシング検知
    └── URL/メール内容のNLP分析

対応（Response）
├── 自動ブロック
│   ├── 不審IPの自動遮断
│   └── 異常アカウントの自動ロック
├── インシデント分類
│   └── アラートの優先度自動判定
└── 修復提案
    └── LLMによる対応手順の生成

予防（Prevention）
├── 脆弱性予測
│   └── コード変更のリスクスコアリング
├── 設定ミス検出
│   └── IaCのセキュリティスキャン
└── 脅威インテリジェンス
    └── 新しい攻撃パターンの予測
\`\`\`

### 異常検知（Anomaly Detection）の基本

異常検知は、AIセキュリティの中核技術です。「正常な状態」を学習して、そこから逸脱する行動を検出します。

スタートアップでも実装できるシンプルな異常検知の考え方を紹介します。

\`\`\`python
# シンプルなログイン異常検知の例
# （実務ではもっと多くの特徴量を使います）

import numpy as np
from collections import defaultdict

class LoginAnomalyDetector:
    def __init__(self):
        self.user_profiles = defaultdict(lambda: {
            "login_hours": [],      # ログイン時間帯
            "login_ips": set(),     # 過去のIPアドレス
            "login_countries": set(), # 過去の国
            "avg_interval": 0,      # 平均ログイン間隔
        })

    def check_login(self, user_id, hour, ip, country):
        profile = self.user_profiles[user_id]
        risk_score = 0
        reasons = []

        # 1. 普段と異なる時間帯
        if profile["login_hours"]:
            mean_hour = np.mean(profile["login_hours"])
            std_hour = np.std(profile["login_hours"]) or 2
            if abs(hour - mean_hour) > 2 * std_hour:
                risk_score += 30
                reasons.append("unusual_hour")

        # 2. 新しいIPアドレス
        if profile["login_ips"] and ip not in profile["login_ips"]:
            risk_score += 20
            reasons.append("new_ip")

        # 3. 新しい国からのアクセス
        if profile["login_countries"] and country not in profile["login_countries"]:
            risk_score += 40
            reasons.append("new_country")

        # プロファイルを更新
        profile["login_hours"].append(hour)
        profile["login_ips"].add(ip)
        profile["login_countries"].add(country)

        return {
            "risk_score": min(risk_score, 100),
            "reasons": reasons,
            "action": "block" if risk_score >= 70 else
                      "mfa" if risk_score >= 40 else "allow"
        }

# 使用例
detector = LoginAnomalyDetector()
result = detector.check_login("user123", hour=3, ip="203.0.113.50", country="RU")
# → {"risk_score": 70, "reasons": ["unusual_hour", "new_country"], "action": "block"}
\`\`\`

これは簡略版ですが、原理はこの通りです。実務では、デバイスフィンガープリント、クリックパターン、セッション時間なども特徴量に加えます。

### SIEM/SOAR — セキュリティ運用の自動化

**SIEM（Security Information and Event Management）** は、あらゆるログを集約して異常を検知するプラットフォームです。**SOAR（Security Orchestration, Automation and Response）** は、検知されたインシデントへの対応を自動化する仕組みです。

\`\`\`
【SIEM + SOARの連携フロー】

ログ収集 → SIEM（分析・検知） → SOAR（自動対応）

例: 不正ログイン検知の自動化フロー

1. [ログ収集] CloudWatch / Auth0のログをSIEMに送信
2. [検知ルール] 同一IPから5分以内に10回以上の認証失敗
3. [アラート] SIEMが「ブルートフォース攻撃の疑い」アラートを生成
4. [自動対応] SOARが以下を自動実行:
   - 該当IPをWAFでブロック（15分間）
   - 対象アカウントにMFAを強制
   - Slackのセキュリティチャンネルに通知
   - Jiraにインシデントチケットを作成
5. [人間の判断] セキュリティ担当者がチケットを確認し、
   永続的なブロックが必要か判断
\`\`\`

スタートアップ向けの現実的な選択肢としては：

- **Datadog Security Monitoring** — すでにDatadogを使っているなら追加コストが低い
- **AWS Security Hub + GuardDuty** — AWS環境ならネイティブで使える
- **Wazuh** — オープンソースのSIEM。コストを抑えたいスタートアップに最適

### EnablerDAOのSecurity Scannerケーススタディ

Enablerでは、DAOコミュニティ向けにセキュリティスキャナーを開発しました。これはAIを活用したリアルタイムの脅威検知ツールです。

このスキャナーがやっていることは：

1. **スマートコントラクトの静的解析** — 既知の脆弱性パターンとAIによる未知パターンの検出
2. **トランザクションの異常検知** — 通常と異なる送金パターンや、フラッシュローン攻撃の予兆を検出
3. **フィッシングサイトの検出** — DAO関連のフィッシングサイトをクロールし、NLPで類似度を判定
4. **アラートと自動対応** — 検知結果をSlack/Discordに通知し、緊急度に応じて自動でガバナンス投票を提起

このプロジェクトで学んだのは、**AIによる検知は「完璧」を目指すと使い物にならない**ということ。偽陽性（誤検知）が多すぎるとアラート疲れを起こし、本当の脅威を見逃します。検知精度と誤検知率のバランスが、運用上最も重要なチューニングポイントです。

### AI活用時のルール設計

AIを使った脅威検知を導入するときのルール設計の基本を紹介します。

\`\`\`yaml
# 異常検知ルールの定義例（YAML形式）
rules:
  - name: "ブルートフォース攻撃検知"
    condition:
      event: "auth.login_failed"
      threshold: 10
      window: "5m"
      group_by: "source_ip"
    severity: "high"
    action:
      - block_ip:
          duration: "15m"
      - notify:
          channel: "#security-alerts"
      - create_ticket:
          priority: "P2"

  - name: "大量データエクスポート検知"
    condition:
      event: "data.export"
      threshold: 100  # 100件以上のレコード
      window: "10m"
      group_by: "user_id"
    severity: "critical"
    action:
      - suspend_user:
          reason: "異常なデータエクスポート"
      - notify:
          channel: "#security-critical"
      - create_ticket:
          priority: "P1"

  - name: "深夜の管理者操作検知"
    condition:
      event: "admin.*"
      time_range: "00:00-06:00"
      exclude_users: ["scheduled_jobs"]
    severity: "medium"
    action:
      - require_mfa_reverify: true
      - notify:
          channel: "#security-alerts"
\`\`\`

### ポイント

- AIセキュリティは「検知」「対応」「予防」の3層で考える
- 異常検知は「正常な状態」を学習し、逸脱を検出する仕組み。完璧を目指さず、偽陽性とのバランスが重要
- SIEM（分析・検知）とSOAR（自動対応）の組み合わせで、セキュリティ運用を自動化する
- スタートアップでも、Wazuh（OSS）やクラウドネイティブツール（GuardDuty等）で始められる
- ルール設計は「閾値」「時間窓」「重要度」「対応アクション」の4要素で構成する

### 実践ワーク

あなたのサービスの異常検知ルールを3つ設計してください：

1. 認証に関する異常検知ルールを1つ（例：ブルートフォース、パスワードスプレー等）
2. データアクセスに関する異常検知ルールを1つ（例：大量ダウンロード、権限外アクセス等）
3. AI利用に関する異常検知ルールを1つ（例：APIの異常呼び出し、プロンプトインジェクション試行等）

各ルールについて、以下を記述してください：
- 検知条件（イベント、閾値、時間窓）
- 重要度（low / medium / high / critical）
- 自動対応アクション
- 人間がレビューすべき判断ポイント

「どこまで自動化し、どこから人間が判断するか」の線引きが、実運用のカギです。`;

export const lesson11Content = `## 第11回：スタートアップのセキュリティ最小構成

こんにちは、濱田優貴です。

今回は、このコースで最も実践的な回かもしれません。スタートアップが「今日から」実装できるセキュリティの最小構成をお伝えします。

Enablerを立ち上げるとき、僕はメルカリ時代に見てきた「理想のセキュリティ体制」が頭にありました。でもスタートアップの現実は違う。エンジニアは2~3人、予算は限られている、そしてプロダクトのローンチが最優先。その中で「何をやって、何を後回しにするか」を決めるのが最も難しい判断でした。

### Minimum Viable Security（MVS）

「Minimum Viable Product（MVP）」と同じ発想で、**Minimum Viable Security（MVS）** を考えましょう。すべてを完璧にするのではなく、リスクの大きさに応じて優先順位をつけます。

\`\`\`
【MVS優先度マトリクス】

Priority 1: 今日やる（1日で完了）
├── HTTPS強制（Let's Encrypt / Cloudflare）
├── セキュリティヘッダーの設定
├── 環境変数での秘密情報管理
└── 依存パッケージの脆弱性スキャン

Priority 2: 今週やる（2-3日で完了）
├── 認証基盤の構築（パスキー + ソーシャルログイン）
├── CSP（Content Security Policy）の設定
├── レートリミットの実装
└── 基本的なログ収集

Priority 3: 今月やる（1-2週間で完了）
├── 自動バックアップの設定
├── CI/CDにセキュリティスキャンを組み込む
├── WAF（Web Application Firewall）の導入
└── インシデント対応手順の策定

Priority 4: 次のクォーターでやる
├── SOC 2 Type II取得の準備
├── ペネトレーションテスト実施
├── SIEM/監視基盤の構築
└── セキュリティトレーニングの実施
\`\`\`

### クラウドセキュリティの基本

AWS、GCP、Azureのいずれを使う場合でも、まず押さえるべきことは共通しています。

**1. ルートアカウントのロック**

\`\`\`
【クラウドアカウントの初期設定チェックリスト】

□ ルート/管理者アカウントにMFAを設定（ハードウェアキー推奨）
□ ルートアカウントのアクセスキーを削除
□ 日常作業用のIAMユーザー/ロールを作成
□ 最小権限の原則（必要な権限だけ付与）
□ CloudTrail/監査ログを有効化
□ 予算アラートを設定（不正利用の早期発見にも有効）
\`\`\`

**2. ネットワークの基本**

\`\`\`
VPC設計の最小構成:
┌─────────────────────────────────┐
│ VPC (10.0.0.0/16)                │
│ ┌──────────────┐ ┌────────────┐ │
│ │ Public Subnet │ │ Private    │ │
│ │              │ │ Subnet     │ │
│ │ ALB / CDN    │ │ App / DB   │ │
│ │              │ │            │ │
│ └──────────────┘ └────────────┘ │
│                                  │
│ ルール: DBはPrivateに配置。       │
│ PublicからPrivateへのみ通信可。   │
│ SecurityGroupは最小限のポートのみ。│
└─────────────────────────────────┘
\`\`\`

### 無料・低コストで使えるセキュリティツール

スタートアップの味方になる、コスパの高いセキュリティツールを紹介します。

\`\`\`
【無料/低コストセキュリティツール一覧】

脆弱性スキャン:
  - npm audit / yarn audit — Node.jsの依存関係チェック（無料）
  - Snyk — オープンソース脆弱性スキャン（無料枠あり）
  - Trivy — コンテナイメージの脆弱性スキャン（OSS無料）

コードスキャン:
  - GitHub Advanced Security — Dependabot + CodeQL（publicリポは無料）
  - Semgrep — 静的解析ツール（OSS版無料）

インフラ:
  - Cloudflare — CDN + DDoS保護 + WAF（無料プランあり）
  - Let's Encrypt — SSL/TLS証明書（無料）
  - AWS GuardDuty — 脅威検知（30日無料トライアル）

監視:
  - Sentry — エラー監視（無料枠あり）
  - Better Stack (旧Logtail) — ログ管理（無料枠あり）

パスワード管理:
  - 1Password — チーム向けパスワード管理（スタートアッププログラムあり）
\`\`\`

### セキュリティヘッダーの完全設定

Next.jsアプリを例に、本番環境で必須のセキュリティヘッダーを設定しましょう。これは**今日やるべきPriority 1**です。

\`\`\`typescript
// next.config.ts
import type { NextConfig } from "next";

const securityHeaders = [
  {
    // XSSフィルタを有効化
    key: "X-XSS-Protection",
    value: "1; mode=block",
  },
  {
    // iframe埋め込みを禁止（クリックジャッキング対策）
    key: "X-Frame-Options",
    value: "DENY",
  },
  {
    // MIMEタイプスニッフィングを禁止
    key: "X-Content-Type-Options",
    value: "nosniff",
  },
  {
    // リファラー情報の制御
    key: "Referrer-Policy",
    value: "strict-origin-when-cross-origin",
  },
  {
    // HTTPS強制（1年間、サブドメイン含む）
    key: "Strict-Transport-Security",
    value: "max-age=31536000; includeSubDomains; preload",
  },
  {
    // Permissions Policy（不要なブラウザ機能を無効化）
    key: "Permissions-Policy",
    value: "camera=(), microphone=(), geolocation=(), interest-cohort=()",
  },
  {
    // Content Security Policy
    key: "Content-Security-Policy",
    value: [
      "default-src 'self'",
      "script-src 'self' 'unsafe-eval' 'unsafe-inline'", // 本番ではunsafe削除推奨
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "font-src 'self'",
      "connect-src 'self' https://api.yourservice.com",
      "frame-ancestors 'none'",
      "base-uri 'self'",
      "form-action 'self'",
    ].join("; "),
  },
];

const nextConfig: NextConfig = {
  async headers() {
    return [
      {
        source: "/(.*)",
        headers: securityHeaders,
      },
    ];
  },
  // HTTPSリダイレクト（Vercelなら自動、セルフホストなら設定）
  // poweredByHeader: false で X-Powered-By を非表示に
  poweredByHeader: false,
};

export default nextConfig;
\`\`\`

### バックアップと災害復旧の基本

メルカリ時代に学んだ最も重要な教訓の一つ：**バックアップはテストするまでバックアップではない**。

\`\`\`
【バックアップの3-2-1ルール】

3: データのコピーを3つ保持
2: 2つの異なるメディア/サービスに保存
1: 1つはオフサイト（別リージョン/別クラウド）に保存

スタートアップの現実的な構成:
  コピー1: 本番データベース（例: RDS / Supabase）
  コピー2: 自動スナップショット（同リージョン、日次）
  コピー3: クロスリージョンバックアップ（週次）

最重要: 月1回、バックアップからの復旧テストを実施する！
\`\`\`

### 環境変数と秘密情報の管理

\`\`\`
【やってはいけないこと】
✗ .envファイルをGitにコミット
✗ APIキーをソースコードにハードコード
✗ Slackにクレデンシャルを貼り付け
✗ 本番の秘密情報を開発環境で使い回し

【やるべきこと】
✓ .gitignoreに.envを追加（初日に必ず確認）
✓ 本番はクラウドのSecret Manager（AWS Secrets Manager等）を使用
✓ 開発用と本番用で別のAPIキーを発行
✓ シークレットのローテーション（90日ごと推奨）
\`\`\`

Enablerでは、新メンバーが入ったときの最初のオンボーディングで「.envファイルをGitにコミットするとインシデント報告が必要」と伝えています。これくらいの緊張感がちょうどいい。

### ポイント

- セキュリティは「完璧」ではなく「優先順位」で考える。MVSの発想で、リスクの大きいものから潰す
- HTTPS、セキュリティヘッダー、秘密情報管理、依存パッケージスキャンは「今日やる」4大タスク
- 無料・低コストのセキュリティツールを活用する。Cloudflare、Snyk、Semgrepは特に推奨
- クラウドのルートアカウントのMFA設定は、最も単純かつ最も重要なセキュリティ対策
- バックアップは「取っている」だけでは不十分。復旧テストまでやって初めて有効

### 実践ワーク

Next.js（またはあなたのフレームワーク）のプロジェクトに以下のセキュリティ対策をすべて実装してください：

1. 上記のセキュリティヘッダーをすべて設定し、[securityheaders.com](https://securityheaders.com) でA以上の評価を取得する
2. \`.gitignore\`に秘密情報関連のファイルが含まれていることを確認する
3. \`npm audit\`（または\`yarn audit\`）を実行し、Critical/Highの脆弱性がないことを確認する
4. GitHub Dependabotを有効にして、自動で脆弱性アラートが来るようにする
5. プロジェクトの「MVSチェックリスト」をNotion等に作成し、Priority 1~4の各項目の対応状況を記録する

この実践ワークが完了したら、あなたのプロジェクトのセキュリティレベルは「何もやっていないスタートアップの上位10%」に入ります。そこからさらに上を目指すのがPriority 3以降です。`;

export const lesson12Content = `## 第12回：まとめ — AI時代のセキュリティマインドセット

こんにちは、濱田優貴です。

全12回のコース、お疲れさまでした。最終回は、これまでの内容を振り返りつつ、**AI時代にセキュリティとどう向き合っていくか**というマインドセットの話をします。

技術やツールは変わり続けますが、マインドセットは長く使えます。メルカリからEnablerまで、僕自身が経験を通じて培ってきた「セキュリティの考え方」を最後にお伝えしたいと思います。

### 全12回の振り返り

\`\`\`
【コース全体マップ】

基礎理解（第1-3回）
├── 第1回: AIセキュリティの全体像と「なぜ今なのか」
├── 第2回: ChatGPT/Claudeのデータ漏洩リスクと安全な運用
└── 第3回: Prompt Injectionの仕組みと防御

技術設計（第4-6回）
├── 第4回: RAGアプリケーションのセキュリティ設計
├── 第5回: AIエージェント（MCP/Function Calling）の安全な構築
└── 第6回: AI生成コンテンツの法的リスクと著作権

運用・管理（第7-9回）
├── 第7回: SaaS選定のセキュリティチェックリスト
├── 第8回: OAuth/SSO/パスキーによる認証設計
└── 第9回: 個人情報保護法2026年改正とAI

実践・総合（第10-12回）
├── 第10回: AIを使った脅威検知と自動化
├── 第11回: スタートアップのセキュリティ最小構成
└── 第12回: AI時代のセキュリティマインドセット ← 今ここ
\`\`\`

### 創業者のためのセキュリティマインドセット

メルカリとEnablerの経験から、僕が信じているセキュリティの原則が5つあります。

**原則1: セキュリティは「コスト」ではなく「信頼の投資」**

スタートアップの創業者にとって、セキュリティは「お金と時間がかかるもの」に見えがちです。でも視点を変えてください。顧客があなたのサービスにデータを預けるとき、それは信頼の証です。その信頼を裏切れば、プロダクトそのものが終わります。

メルカリが数千万ユーザーに成長できたのは、安心して取引できるプラットフォームだったから。セキュリティへの投資は、ユーザーの信頼への投資です。

**原則2: 「知らなかった」を最小化する**

セキュリティインシデントの多くは、高度なハッキングではなく、単純な「知らなかった」が原因です。.envファイルがGitに上がっていた。APIキーがログに出力されていた。退職者のアカウントが削除されていなかった。

このコースを受講したあなたは、もう「知らなかった」とは言えない立場です。そして、チームメンバーにも「知っている」状態を広げていくのがあなたの責任です。

**原則3: 完璧を目指さず、継続的に改善する**

セキュリティに完璧はありません。攻撃手法は日々進化し、新しい脆弱性は毎日発見されます。大事なのは、**今日より明日の方がセキュアである状態を維持し続けること**です。

\`\`\`
【セキュリティ成熟度モデル（スタートアップ版）】

Level 0: 何もしていない
  → 大半のスタートアップがここからスタート

Level 1: 基本対策を実施（このコース修了時点）
  → HTTPS、セキュリティヘッダー、認証基盤、秘密情報管理

Level 2: プロセスを確立
  → CI/CDにセキュリティスキャン、定期的な脆弱性チェック、
    インシデント対応手順の策定

Level 3: 文化として定着
  → 全メンバーがセキュリティを意識、Secure by Designの開発、
    定期的なセキュリティトレーニング

Level 4: 外部認証の取得
  → SOC 2 Type II、ISO 27001、ペネトレーションテスト定期実施

目標: 6ヶ月でLevel 2、1年でLevel 3に到達する
\`\`\`

**原則4: AIをリスクとしてだけでなく、味方としても活用する**

第10回で学んだように、AIは脅威にもなれば防御の武器にもなります。AIツールを使ったコードレビュー、異常検知、脆弱性スキャンは、少人数のスタートアップにとって大きな力になります。

ただし、**AIに任せっぱなしにしない**。AIは強力な補助ツールですが、最終的な判断は人間がするべきです。これは第5回のAIエージェントの話にも通じます。

**原則5: セキュリティはチーム全員の責任**

メルカリのセキュリティチームは優秀でしたが、彼らだけでは守りきれなかった。プロダクトを作るエンジニア、運用するチーム、企画するPM、そして経営者。全員がセキュリティの基本を理解して初めて、組織として強くなれます。

### セキュリティ文化の作り方

具体的に、チームにセキュリティ文化を根付かせる方法を紹介します。

1. **オンボーディングにセキュリティ研修を組み込む** — 新メンバーが入ったら、最初の1週間で「やってはいけないこと」を共有する
2. **セキュリティチャンピオンを任命する** — チームの中でセキュリティに詳しい人を1人決め、レビューやトレーニングの窓口にする
3. **ポストモーテムを公開する** — インシデントが起きたら隠さず、原因と対策を全員に共有する。blame-freeな文化が大事
4. **セキュリティを称える** — 脆弱性を発見した人を叱るのではなく、褒める。報告しやすい環境を作る

### 学び続けるためのリソース

セキュリティは日進月歩の領域です。継続的に学ぶためのリソースを紹介します。

\`\`\`
【推奨リソース】

日本語:
  - IPA（情報処理推進機構）— 「安全なウェブサイトの作り方」等
  - JPCERT/CC — 脆弱性情報、インシデント対応
  - LAC セキュリティブログ — 実践的な技術情報

英語:
  - OWASP — Web/API/LLMセキュリティのバイブル
  - Krebs on Security — セキュリティニュース
  - tl;dr sec — 週刊セキュリティニュースレター
  - The Hacker News — セキュリティニュース速報

ハンズオン:
  - PortSwigger Web Security Academy — 無料のセキュリティ学習
  - TryHackMe / Hack The Box — 実践的なペンテスト学習
  - CryptoHack — 暗号技術の学習

コミュニティ:
  - EnablerDAO Security Community — 本コースの受講者コミュニティ
  - OWASP Japan Chapter — 定期的な勉強会
\`\`\`

### 90日セキュリティ改善プラン

最後に、このコースの内容を実務に落とし込むための90日プランを提案します。

\`\`\`
【90日セキュリティ改善プラン】

■ Day 1-7: 緊急対応（Priority 1）
  □ HTTPS強制 & セキュリティヘッダー設定
  □ 全アカウントのMFA有効化
  □ .envファイルのGit履歴チェック & 秘密情報のローテーション
  □ npm audit / yarn auditでCriticalな脆弱性を修正
  □ SaaS棚卸し（使っているサービスの一覧作成）

■ Day 8-30: 基盤構築（Priority 2）
  □ 認証基盤の見直し（パスキー/SSO対応検討）
  □ CSP（Content Security Policy）の設定
  □ APIレートリミットの実装
  □ ログ収集基盤の構築
  □ バックアップの設定 & 復旧テスト
  □ プライバシーポリシーの更新（AI利用に関する記載）

■ Day 31-60: プロセス確立（Priority 3）
  □ CI/CDにセキュリティスキャンを組み込む（Semgrep / Snyk）
  □ Dependabotの有効化
  □ インシデント対応手順の策定
  □ SaaS選定セキュリティチェックリストの運用開始
  □ AI利用ガイドラインの策定と全社共有
  □ PIA（プライバシー影響評価）テンプレートの導入

■ Day 61-90: 文化醸成（Priority 4の準備）
  □ チーム向けセキュリティトレーニングの実施
  □ セキュリティチャンピオンの任命
  □ 脅威検知ルールの設計・テスト
  □ ペネトレーションテストの計画（外部業者の選定）
  □ SOC 2 / ISO 27001取得のロードマップ作成
  □ 90日の振り返り & 次の90日の計画策定
\`\`\`

### ポイント

- セキュリティは「コスト」ではなく「信頼への投資」。ユーザーの信頼がプロダクトの生命線
- 「知らなかった」を最小化することが、最も費用対効果の高いセキュリティ対策
- 完璧を目指さず、今日より明日セキュアである状態を継続する
- AIをリスクとしてだけでなく、防御の味方として活用する
- セキュリティはチーム全員の責任。文化として根付かせることが最終ゴール

### 実践ワーク

あなたの組織（またはプロジェクト）のための「90日セキュリティ改善プラン」をカスタマイズして作成してください：

1. 上記のテンプレートをベースに、あなたの状況に合わせて項目を追加・削除する
2. 各項目に「担当者」と「期限」を設定する
3. 現時点のセキュリティ成熟度（Level 0~4）を自己評価する
4. 90日後に到達したい成熟度レベルを設定する
5. このプランをチームメンバー全員に共有し、最初のキックオフミーティングの日程を決める

このコースで学んだ知識は、実行しなければ意味がありません。90日後に振り返ったとき、「あのコースを受けてよかった」と思えるように、今日から一歩を踏み出してください。

全12回、ありがとうございました。皆さんのプロダクトが、ユーザーに信頼されるセキュアなサービスになることを願っています。一緒にAI時代のセキュリティを作っていきましょう。`;
